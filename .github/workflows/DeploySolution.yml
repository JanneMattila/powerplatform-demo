name: Deploy Solutions (Orchestrator)
run-name: Deploy ${{ inputs.solution || 'Auto-triggered' }}${{ inputs.deploy_dependencies && ' with dependencies ' || ' ' }}${{ inputs.environment || '' }}

on:
  workflow_dispatch:
    inputs:
      solution:
        description: 'Solution to deploy'
        required: true
        type: choice
        options:
          - 'Calculator -> 1. Calculator'
          - 'Library -> 1. LibraryTables'
          - 'Library -> 2. LibraryApp'
          - 'MyVacations -> 1. MyVacationsTables'
          - 'MyVacations -> 2. MyVacationsApp'
          - 'Garage -> 1. Garage'
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - 'QA'
          - 'Production'
      deploy_dependencies:
        description: 'Deploy dependencies?'
        required: false
        default: false
        type: boolean
  pull_request:
  # push:
  #   paths-ignore:
  #     - '.github/workflows/**'
  #     - 'SolutionGroups/solution-groups.json'
  #     - 'docs/**'
  #     - 'README.md'
  #   branches:
  #     - main

permissions:
  contents: read
  actions: write
  pull-requests: read

jobs:
  OrchestrateQADeploy:
    if: github.event_name == 'pull_request'
    environment: QA
    runs-on: ubuntu-latest
    name: Orchestrate QA Deployment
    steps:
      - name: Check out
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 1
        env:
          GIT_LFS_SKIP_SMUDGE: 1

      - name: Detect solutions from PR
        id: detect
        run: |
          echo "Detecting solutions from PR changes..."
          
          # Get list of changed *_unmanaged.zip files in the PR
          CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' | grep '_unmanaged.zip$' || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No *_unmanaged.zip files found in PR changes. Assuming that this is not a solution deployment PR."
            SOLUTIONS="[]"
            echo "solutions=$SOLUTIONS" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Read solution-groups.json to get proper ordering
          SOLUTION_GROUPS=$(cat SolutionGroups/solution-groups.json)
          
          # Process each file and create a map with ordering info
          declare -A SOLUTION_MAP
          while IFS= read -r file; do
            # Extract solution group and app name from path
            # Expected format: SolutionGroups/Library/LibraryTables_unmanaged.zip
            SOLUTION_GROUP=$(echo "$file" | cut -d'/' -f2)
            APP_NAME=$(basename "$file" _unmanaged.zip)
            
            # Find the index of this app in the solution group array
            INDEX=$(echo "$SOLUTION_GROUPS" | jq -r --arg sg "$SOLUTION_GROUP" --arg app "$APP_NAME" '.[$sg] | to_entries[] | select(.value == $app) | .key')
            
            if [ -n "$INDEX" ]; then
              # Store with key "group_index_appname" for sorting
              KEY="${SOLUTION_GROUP}_${INDEX}_${APP_NAME}"
              SOLUTION_MAP[$KEY]="${SOLUTION_GROUP}|${APP_NAME}|${INDEX}"
            else
              echo "Warning: App '$APP_NAME' not found in solution group '$SOLUTION_GROUP' in solution-groups.json"
            fi
          done <<< "$CHANGED_FILES"
          
          # Sort by solution group and index, then build JSON array in correct order
          SOLUTIONS="[]"
          for KEY in $(printf '%s\n' "${!SOLUTION_MAP[@]}" | sort); do
            VALUE="${SOLUTION_MAP[$KEY]}"
            SOLUTION_GROUP=$(echo "$VALUE" | cut -d'|' -f1)
            APP_NAME=$(echo "$VALUE" | cut -d'|' -f2)
            INDEX=$(echo "$VALUE" | cut -d'|' -f3)
            
            # Add to solutions array in order (use -c for compact output)
            SOLUTIONS=$(echo "$SOLUTIONS" | jq -c --arg sg "$SOLUTION_GROUP" --arg app "$APP_NAME" --argjson idx "$INDEX" '. += [{"solution_group": $sg, "app_name": $app, "order": $idx}]')
          done
          
          echo "solutions=$SOLUTIONS" >> $GITHUB_OUTPUT
          echo "Detected solutions in deployment order:"
          echo "$SOLUTIONS" | jq .
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Orchestrate deployments to QA
        uses: actions/github-script@v7
        env:
          SOLUTIONS: ${{ steps.detect.outputs.solutions }}
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
        with:
          script: |
            const solutions = JSON.parse(process.env.SOLUTIONS);
            const totalCount = solutions.length;
            const headRef = process.env.HEAD_REF;
            
            console.log(`Will deploy ${totalCount} solution(s) to QA`);
            console.log(`Using branch: ${headRef}`);
            
            // Deploy each solution sequentially
            for (let i = 0; i < solutions.length; i++) {
              const solution = solutions[i];
              const displayNumber = i + 1;
              
              console.log(`\n========================================`);
              console.log(`Triggering deployment ${displayNumber} of ${totalCount}`);
              console.log(`Solution: ${solution.solution_group} -> ${solution.app_name}`);
              console.log(`Environment: QA`);
              console.log(`========================================`);
              
              // Trigger the workflow on the PR head branch
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'DeployOneSolution.yml',
                ref: headRef,
                inputs: {
                  solution_group: solution.solution_group,
                  app_name: solution.app_name,
                  environment: 'QA'
                }
              });
              
              // Wait a moment for the workflow to be created
              console.log(`Waiting for workflow to be created...`);
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Poll for workflow completion
              let workflowRun = null;
              let attempts = 0;
              const maxAttempts = 360; // 30 minutes max wait (360 * 5 seconds)
              let workflowStartLogged = false;
              
              while (attempts < maxAttempts) {
                // Get recent workflow runs with retry logic
                let runs;
                let retryCount = 0;
                const maxRetries = 3;
                
                while (retryCount < maxRetries) {
                  try {
                    runs = await github.rest.actions.listWorkflowRuns({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      workflow_id: 'DeployOneSolution.yml',
                      per_page: 10
                    });
                    break; // Success, exit retry loop
                  } catch (error) {
                    retryCount++;
                    if (retryCount >= maxRetries) {
                      console.error(`Failed to fetch workflow runs after ${maxRetries} retries: ${error.message}`);
                      throw error;
                    }
                    const retryDelay = Math.min(1000 * Math.pow(2, retryCount), 10000); // Exponential backoff, max 10s
                    console.log(`API call failed (attempt ${retryCount}/${maxRetries}), retrying in ${retryDelay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                  }
                }
                
                // Find the most recent run for this branch (should be the one we just triggered)
                const recentRun = runs.data.workflow_runs.find(run => 
                  run.head_branch === headRef &&
                  (run.status === 'completed' || run.status === 'in_progress' || run.status === 'queued')
                );
                
                if (recentRun && !workflowStartLogged) {
                  console.log(`Workflow ${displayNumber} started: ${recentRun.html_url}`);
                  workflowStartLogged = true;
                }
                
                if (recentRun && recentRun.status === 'completed') {
                  workflowRun = recentRun;
                  console.log(`\nWorkflow ${displayNumber} completed with status: ${recentRun.conclusion}`);
                  console.log(`View workflow run: ${recentRun.html_url}`);
                  break;
                }
                
                if (attempts % 6 === 0) { // Log every 30 seconds
                  console.log(`Waiting for workflow ${displayNumber} to complete... (${Math.floor(attempts * 5 / 60)}m ${(attempts * 5) % 60}s elapsed)`);
                }
                
                await new Promise(resolve => setTimeout(resolve, 5000));
                attempts++;
              }
              
              // Check if workflow succeeded
              if (!workflowRun) {
                core.setFailed(`Workflow ${displayNumber} (${solution.app_name}) did not complete within the timeout period (15 minutes)`);
                throw new Error(`Workflow ${displayNumber} timed out`);
              }
              
              if (workflowRun.conclusion !== 'success') {
                core.setFailed(`Workflow ${displayNumber} (${solution.app_name}) failed with conclusion: ${workflowRun.conclusion}. View run: ${workflowRun.html_url}`);
                throw new Error(`Workflow ${displayNumber} failed, stopping execution`);
              }
              
              console.log(`✓ Workflow ${displayNumber} (${solution.app_name}) succeeded`);
              
              if (i < solutions.length - 1) {
                console.log(`Proceeding to next deployment...`);
              }
            }
            
            console.log(`\n========================================`);
            console.log(`✓ All ${totalCount} deployment(s) to QA completed successfully!`);
            console.log(`========================================`);

  # OrchestrateProductionDeploy:
  #   if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  #   environment: Production
  #   runs-on: ubuntu-latest
  #   name: Orchestrate Production Deployment
  #   steps:
  #     - name: Check out
  #       uses: actions/checkout@v5.0.0
  #       with:
  #         fetch-depth: 2
  #       env:
  #         GIT_LFS_SKIP_SMUDGE: 1

  #     - name: Detect solutions from commit
  #       id: detect
  #       run: |
  #         echo "Detecting solutions from commit changes..."
          
  #         # Get list of changed *_unmanaged.zip files in the last commit
  #         CHANGED_FILES=$(git diff --name-only HEAD^ HEAD | grep '_unmanaged.zip$' || true)
          
  #         if [ -z "$CHANGED_FILES" ]; then
  #           echo "No *_unmanaged.zip files found in commit changes"
  #           echo "solutions=[]" >> $GITHUB_OUTPUT
  #           exit 0
  #         fi
          
  #         echo "Changed files:"
  #         echo "$CHANGED_FILES"
          
  #         # Read solution-groups.json to get proper ordering
  #         SOLUTION_GROUPS=$(cat SolutionGroups/solution-groups.json)
          
  #         # Process each file and create a map with ordering info
  #         declare -A SOLUTION_MAP
  #         while IFS= read -r file; do
  #           # Extract solution group and app name from path
  #           # Expected format: SolutionGroups/Library/LibraryTables_unmanaged.zip
  #           SOLUTION_GROUP=$(echo "$file" | cut -d'/' -f2)
  #           APP_NAME=$(basename "$file" _unmanaged.zip)
            
  #           # Find the index of this app in the solution group array
  #           INDEX=$(echo "$SOLUTION_GROUPS" | jq -r --arg sg "$SOLUTION_GROUP" --arg app "$APP_NAME" '.[$sg] | to_entries[] | select(.value == $app) | .key')
            
  #           if [ -n "$INDEX" ]; then
  #             # Store with key "group_index_appname" for sorting
  #             KEY="${SOLUTION_GROUP}_${INDEX}_${APP_NAME}"
  #             SOLUTION_MAP[$KEY]="${SOLUTION_GROUP}|${APP_NAME}|${INDEX}"
  #           else
  #             echo "Warning: App '$APP_NAME' not found in solution group '$SOLUTION_GROUP' in solution-groups.json"
  #           fi
  #         done <<< "$CHANGED_FILES"
          
  #         # Sort by solution group and index, then build JSON array in correct order
  #         SOLUTIONS="[]"
  #         for KEY in $(printf '%s\n' "${!SOLUTION_MAP[@]}" | sort); do
  #           VALUE="${SOLUTION_MAP[$KEY]}"
  #           SOLUTION_GROUP=$(echo "$VALUE" | cut -d'|' -f1)
  #           APP_NAME=$(echo "$VALUE" | cut -d'|' -f2)
  #           INDEX=$(echo "$VALUE" | cut -d'|' -f3)
            
  #           # Add to solutions array in order (use -c for compact output)
  #           SOLUTIONS=$(echo "$SOLUTIONS" | jq -c --arg sg "$SOLUTION_GROUP" --arg app "$APP_NAME" --argjson idx "$INDEX" '. += [{"solution_group": $sg, "app_name": $app, "order": $idx}]')
  #         done
          
  #         echo "solutions=$SOLUTIONS" >> $GITHUB_OUTPUT
  #         echo "Detected solutions in deployment order:"
  #         echo "$SOLUTIONS" | jq .

  #     - name: Orchestrate deployments to Production
  #       if: steps.detect.outputs.solutions != '[]'
  #       uses: actions/github-script@v7
  #       env:
  #         SOLUTIONS: ${{ steps.detect.outputs.solutions }}
  #       with:
  #         script: |
  #           const solutions = JSON.parse(process.env.SOLUTIONS);
            
  #           if (solutions.length === 0) {
  #             console.log('No solutions to deploy');
  #             return;
  #           }
            
  #           const totalCount = solutions.length;
            
  #           console.log(`Will deploy ${totalCount} solution(s) to Production`);
            
  #           // Deploy each solution sequentially
  #           for (let i = 0; i < solutions.length; i++) {
  #             const solution = solutions[i];
  #             const displayNumber = i + 1;
              
  #             console.log(`\n========================================`);
  #             console.log(`Triggering deployment ${displayNumber} of ${totalCount}`);
  #             console.log(`Solution: ${solution.solution_group} -> ${solution.app_name}`);
  #             console.log(`Environment: Production`);
  #             console.log(`========================================`);
              
  #             // Trigger the workflow
  #             await github.rest.actions.createWorkflowDispatch({
  #               owner: context.repo.owner,
  #               repo: context.repo.repo,
  #               workflow_id: 'DeployOneSolution.yml',
  #               ref: 'main',
  #               inputs: {
  #                 solution_group: solution.solution_group,
  #                 app_name: solution.app_name,
  #                 environment: 'Production'
  #               }
  #             });
              
  #             // Wait a moment for the workflow to be created
  #             console.log(`Waiting for workflow to be created...`);
  #             await new Promise(resolve => setTimeout(resolve, 5000));
              
  #             // Poll for workflow completion
  #             let workflowRun = null;
  #             let attempts = 0;
  #             const maxAttempts = 180; // 15 minutes max wait (180 * 5 seconds)
  #             let workflowStartLogged = false;
              
  #             while (attempts < maxAttempts) {
  #               // Get recent workflow runs with retry logic
  #               let runs;
  #               let retryCount = 0;
  #               const maxRetries = 3;
                
  #               while (retryCount < maxRetries) {
  #                 try {
  #                   runs = await github.rest.actions.listWorkflowRuns({
  #                     owner: context.repo.owner,
  #                     repo: context.repo.repo,
  #                     workflow_id: 'DeployOneSolution.yml',
  #                     per_page: 10
  #                   });
  #                   break; // Success, exit retry loop
  #                 } catch (error) {
  #                   retryCount++;
  #                   if (retryCount >= maxRetries) {
  #                     console.error(`Failed to fetch workflow runs after ${maxRetries} retries: ${error.message}`);
  #                     throw error;
  #                   }
  #                   const retryDelay = Math.min(1000 * Math.pow(2, retryCount), 10000); // Exponential backoff, max 10s
  #                   console.log(`API call failed (attempt ${retryCount}/${maxRetries}), retrying in ${retryDelay}ms...`);
  #                   await new Promise(resolve => setTimeout(resolve, retryDelay));
  #                 }
  #               }
                
  #               // Find the most recent run for main branch (should be the one we just triggered)
  #               const recentRun = runs.data.workflow_runs.find(run => 
  #                 run.head_branch === 'main' &&
  #                 (run.status === 'completed' || run.status === 'in_progress' || run.status === 'queued')
  #               );
                
  #               if (recentRun && !workflowStartLogged) {
  #                 console.log(`Workflow ${displayNumber} started: ${recentRun.html_url}`);
  #                 workflowStartLogged = true;
  #               }
                
  #               if (recentRun && recentRun.status === 'completed') {
  #                 workflowRun = recentRun;
  #                 console.log(`\nWorkflow ${displayNumber} completed with status: ${recentRun.conclusion}`);
  #                 console.log(`View workflow run: ${recentRun.html_url}`);
  #                 break;
  #               }
                
  #               if (attempts % 6 === 0) { // Log every 30 seconds
  #                 console.log(`Waiting for workflow ${displayNumber} to complete... (${Math.floor(attempts * 5 / 60)}m ${(attempts * 5) % 60}s elapsed)`);
  #               }
                
  #               await new Promise(resolve => setTimeout(resolve, 5000));
  #               attempts++;
  #             }
              
  #             // Check if workflow succeeded
  #             if (!workflowRun) {
  #               core.setFailed(`Workflow ${displayNumber} (${solution.app_name}) did not complete within the timeout period (15 minutes)`);
  #               throw new Error(`Workflow ${displayNumber} timed out`);
  #             }
              
  #             if (workflowRun.conclusion !== 'success') {
  #               core.setFailed(`Workflow ${displayNumber} (${solution.app_name}) failed with conclusion: ${workflowRun.conclusion}. View run: ${workflowRun.html_url}`);
  #               throw new Error(`Workflow ${displayNumber} failed, stopping execution`);
  #             }
              
  #             console.log(`✓ Workflow ${displayNumber} (${solution.app_name}) succeeded`);
              
  #             if (i < solutions.length - 1) {
  #               console.log(`Proceeding to next deployment...`);
  #             }
  #           }
            
  #           console.log(`\n========================================`);
  #           console.log(`✓ All ${totalCount} deployment(s) to Production completed successfully!`);
  #           console.log(`========================================`);

  OrchestrateManualDeploy:
    if: github.event_name == 'workflow_dispatch' && (inputs.environment != 'Production' || github.ref == 'refs/heads/main')
    runs-on: ubuntu-latest
    name: Orchestrate ${{ inputs.environment || '' }} Deployment
    steps:
      - name: Check out
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 1
        env:
          GIT_LFS_SKIP_SMUDGE: 1

      - name: Parse solution selection
        id: parse
        run: |
          SOLUTION="${{ inputs.solution }}"
          SOLUTION_GROUP=$(echo "$SOLUTION" | cut -d' ' -f1)
          APP_NAME=$(echo "$SOLUTION" | cut -d' ' -f3-)
          # Remove number prefix if present (e.g., "1. LibraryTables" -> "LibraryTables")
          APP_NAME=$(echo "$APP_NAME" | sed 's/^[0-9]\+\. //')
          echo "solution_group=$SOLUTION_GROUP" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Deploying: $SOLUTION_GROUP -> $APP_NAME to ${{ inputs.environment }}"

      - name: Orchestrate deployments
        uses: actions/github-script@v7
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          DEPLOY_DEPENDENCIES: ${{ inputs.deploy_dependencies }}
          SOLUTION_GROUP: ${{ steps.parse.outputs.solution_group }}
          APP_NAME: ${{ steps.parse.outputs.app_name }}
        with:
          script: |
            const fs = require('fs');
            
            // Use parsed values from the parse step
            const solutionGroup = process.env.SOLUTION_GROUP;
            const startAppName = process.env.APP_NAME;
            const environment = process.env.ENVIRONMENT;
            const deployDependent = process.env.DEPLOY_DEPENDENCIES === 'true';
            
            console.log(`Starting sequential deployment for: ${solutionGroup} -> ${startAppName}`);
            console.log(`Target environment: ${environment}`);
            console.log(`Deploy dependencies: ${deployDependent}`);
            
            // Read the solution groups mapping
            const solutionGroups = JSON.parse(fs.readFileSync('./SolutionGroups/solution-groups.json', 'utf8'));
            
            // Get apps array for the selected solution group
            if (!solutionGroups[solutionGroup]) {
              core.setFailed(`Solution group '${solutionGroup}' not found in mapping`);
              return;
            }
            
            const apps = solutionGroups[solutionGroup];
            
            // Find the starting app index
            const startIndex = apps.indexOf(startAppName);
            
            if (startIndex === -1) {
              core.setFailed(`App '${startAppName}' not found in solution group '${solutionGroup}'`);
              return;
            }
            
            // Determine which apps to deploy
            const appsToDeploy = deployDependent ? apps.slice(startIndex) : [startAppName];
            const totalCount = appsToDeploy.length;
            
            console.log(`Will deploy ${totalCount} app(s): ${appsToDeploy.join(', ')}`);
            
            // Deploy each app sequentially
            for (let i = 0; i < appsToDeploy.length; i++) {
              const appName = appsToDeploy[i];
              const displayNumber = i + 1;
              
              console.log(`\n========================================`);
              console.log(`Triggering deployment ${displayNumber} of ${totalCount}`);
              console.log(`App: ${solutionGroup} -> ${appName}`);
              console.log(`Environment: ${environment}`);
              console.log(`========================================`);
              
              // Trigger the workflow
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'DeployOneSolution.yml',
                ref: context.ref,
                inputs: {
                  solution_group: solutionGroup,
                  app_name: appName,
                  environment: environment
                }
              });
              
              // Wait a moment for the workflow to be created
              console.log(`Waiting for workflow to be created...`);
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Poll for workflow completion
              let workflowRun = null;
              let attempts = 0;
              const maxAttempts = 180; // 15 minutes max wait (180 * 5 seconds)
              let workflowStartLogged = false;
              
              while (attempts < maxAttempts) {
                // Get recent workflow runs with retry logic
                let runs;
                let retryCount = 0;
                const maxRetries = 3;
                
                while (retryCount < maxRetries) {
                  try {
                    runs = await github.rest.actions.listWorkflowRuns({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      workflow_id: 'DeployOneSolution.yml',
                      per_page: 10
                    });
                    break; // Success, exit retry loop
                  } catch (error) {
                    retryCount++;
                    if (retryCount >= maxRetries) {
                      console.error(`Failed to fetch workflow runs after ${maxRetries} retries: ${error.message}`);
                      throw error;
                    }
                    const retryDelay = Math.min(1000 * Math.pow(2, retryCount), 10000); // Exponential backoff, max 10s
                    console.log(`API call failed (attempt ${retryCount}/${maxRetries}), retrying in ${retryDelay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                  }
                }
                
                // Find the most recent run (should be the one we just triggered)
                const recentRun = runs.data.workflow_runs.find(run => 
                  (run.status === 'completed' || run.status === 'in_progress' || run.status === 'queued')
                );
                
                if (recentRun && !workflowStartLogged) {
                  console.log(`Workflow ${displayNumber} started: ${recentRun.html_url}`);
                  workflowStartLogged = true;
                }
                
                if (recentRun && recentRun.status === 'completed') {
                  workflowRun = recentRun;
                  console.log(`\nWorkflow ${displayNumber} completed with status: ${recentRun.conclusion}`);
                  console.log(`View workflow run: ${recentRun.html_url}`);
                  break;
                }
                
                if (attempts % 6 === 0) { // Log every 30 seconds
                  console.log(`Waiting for workflow ${displayNumber} to complete... (${Math.floor(attempts * 5 / 60)}m ${(attempts * 5) % 60}s elapsed)`);
                }
                
                await new Promise(resolve => setTimeout(resolve, 5000));
                attempts++;
              }
              
              // Check if workflow succeeded
              if (!workflowRun) {
                core.setFailed(`Workflow ${displayNumber} (${appName}) did not complete within the timeout period (15 minutes)`);
                throw new Error(`Workflow ${displayNumber} timed out`);
              }
              
              if (workflowRun.conclusion !== 'success') {
                core.setFailed(`Workflow ${displayNumber} (${appName}) failed with conclusion: ${workflowRun.conclusion}. View run: ${workflowRun.html_url}`);
                throw new Error(`Workflow ${displayNumber} failed, stopping execution`);
              }
              
              console.log(`✓ Workflow ${displayNumber} (${appName}) succeeded`);
              
              if (i < appsToDeploy.length - 1) {
                console.log(`Proceeding to next deployment...`);
              }
            }
            
            console.log(`\n========================================`);
            console.log(`✓ All ${totalCount} deployment(s) completed successfully!`);
            console.log(`========================================`);
