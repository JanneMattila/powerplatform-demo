name: Deploy Solutions (Orchestrator)
run-name: Deploy ${{ inputs.solution || 'Auto-triggered' }}${{ inputs.deploy_dependencies && ' with dependencies ' || ' ' }}${{ inputs.environment || '' }}

on:
  workflow_dispatch:
    inputs:
      solution:
        description: 'Solution to deploy'
        required: true
        type: choice
        options:
          - 'Library -> 1. LibraryTables'
          - 'Library -> 2. LibraryApp'
          - 'MyVacations -> 1. MyVacationsTables'
          - 'MyVacations -> 2. MyVacationsApp'
          - 'Garage -> 1. Garage'
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - 'QA'
          - 'Production'
      deploy_dependencies:
        description: 'Deploy dependencies?'
        required: false
        default: false
        type: boolean
  pull_request:
  push:
    paths-ignore:
      - '.github/workflows/**'
      - 'SolutionGroups/solution-groups.json'
      - 'docs/**'
      - 'README.md'
    branches:
      - main

permissions:
  contents: read
  actions: write
  pull-requests: read

jobs:
  OrchestrateQADeploy:
    if: github.event_name == 'pull_request'
    environment: QA
    runs-on: ubuntu-latest
    name: Orchestrate QA Deployment
    steps:
      - name: Check out
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 1
        env:
          GIT_LFS_SKIP_SMUDGE: 1

      - name: Detect solutions from PR
        id: detect
        run: |
          echo "Detecting solutions from PR changes..."
          
          # Get list of changed *_unmanaged.zip files in the PR
          CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' | grep '_unmanaged.zip$' || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No *_unmanaged.zip files found in PR changes. Assuming that this is not a solution deployment PR."
            SOLUTIONS="[]"
            echo "solutions=$SOLUTIONS" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Read solution-groups.json to get proper ordering
          SOLUTION_GROUPS=$(cat SolutionGroups/solution-groups.json)
          
          # Process each file and create a map with ordering info
          declare -A SOLUTION_MAP
          while IFS= read -r file; do
            # Extract solution group and app name from path
            # Expected format: SolutionGroups/Library/LibraryTables_unmanaged.zip
            SOLUTION_GROUP=$(echo "$file" | cut -d'/' -f2)
            APP_NAME=$(basename "$file" _unmanaged.zip)
            
            # Find the index of this app in the solution group array
            INDEX=$(echo "$SOLUTION_GROUPS" | jq -r --arg sg "$SOLUTION_GROUP" --arg app "$APP_NAME" '.[$sg] | to_entries[] | select(.value == $app) | .key')
            
            if [ -n "$INDEX" ]; then
              # Store with key "group_index_appname" for sorting
              KEY="${SOLUTION_GROUP}_${INDEX}_${APP_NAME}"
              SOLUTION_MAP[$KEY]="${SOLUTION_GROUP}|${APP_NAME}|${INDEX}"
            else
              echo "Warning: App '$APP_NAME' not found in solution group '$SOLUTION_GROUP' in solution-groups.json"
            fi
          done <<< "$CHANGED_FILES"
          
          # Sort by solution group and index, then build JSON array in correct order
          SOLUTIONS="[]"
          for KEY in $(printf '%s\n' "${!SOLUTION_MAP[@]}" | sort); do
            VALUE="${SOLUTION_MAP[$KEY]}"
            SOLUTION_GROUP=$(echo "$VALUE" | cut -d'|' -f1)
            APP_NAME=$(echo "$VALUE" | cut -d'|' -f2)
            INDEX=$(echo "$VALUE" | cut -d'|' -f3)
            
            # Add to solutions array in order (use -c for compact output)
            SOLUTIONS=$(echo "$SOLUTIONS" | jq -c --arg sg "$SOLUTION_GROUP" --arg app "$APP_NAME" --argjson idx "$INDEX" '. += [{"solution_group": $sg, "app_name": $app, "order": $idx}]')
          done
          
          echo "solutions=$SOLUTIONS" >> $GITHUB_OUTPUT
          echo "Detected solutions in deployment order:"
          echo "$SOLUTIONS" | jq .
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Orchestrate deployments to QA
        uses: actions/github-script@v7
        env:
          SOLUTIONS: ${{ steps.detect.outputs.solutions }}
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
        with:
          script: |
            const solutions = JSON.parse(process.env.SOLUTIONS);
            const totalCount = solutions.length;
            const headRef = process.env.HEAD_REF;
            
            console.log(`Will deploy ${totalCount} solution(s) to QA`);
            console.log(`Using branch: ${headRef}`);
            
            // Deploy each solution sequentially
            for (let i = 0; i < solutions.length; i++) {
              const solution = solutions[i];
              const displayNumber = i + 1;
              
              console.log(`\n========================================`);
              console.log(`Triggering deployment ${displayNumber} of ${totalCount}`);
              console.log(`Solution: ${solution.solution_group} -> ${solution.app_name}`);
              console.log(`Environment: QA`);
              console.log(`========================================`);
              
              // Trigger the workflow on the PR head branch
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'DeployOneSolution.yml',
                ref: headRef,
                inputs: {
                  solution_group: solution.solution_group,
                  app_name: solution.app_name,
                  environment: 'QA'
                }
              });
              
              // Wait a moment for the workflow to be created
              console.log(`Waiting for workflow to be created...`);
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Poll for workflow completion
              let workflowRun = null;
              let attempts = 0;
              const maxAttempts = 360; // 30 minutes max wait (360 * 5 seconds)
              let workflowStartLogged = false;
              
              while (attempts < maxAttempts) {
                // Get recent workflow runs
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'DeployOneSolution.yml',
                  per_page: 10
                });
                
                // Find the most recent run for this branch (should be the one we just triggered)
                const recentRun = runs.data.workflow_runs.find(run => 
                  run.head_branch === headRef &&
                  (run.status === 'completed' || run.status === 'in_progress' || run.status === 'queued')
                );
                
                if (recentRun && !workflowStartLogged) {
                  console.log(`Workflow ${displayNumber} started: ${recentRun.html_url}`);
                  workflowStartLogged = true;
                }
                
                if (recentRun && recentRun.status === 'completed') {
                  workflowRun = recentRun;
                  console.log(`\nWorkflow ${displayNumber} completed with status: ${recentRun.conclusion}`);
                  console.log(`View workflow run: ${recentRun.html_url}`);
                  break;
                }
                
                if (attempts % 6 === 0) { // Log every 30 seconds
                  console.log(`Waiting for workflow ${displayNumber} to complete... (${Math.floor(attempts * 5 / 60)}m ${(attempts * 5) % 60}s elapsed)`);
                }
                
                await new Promise(resolve => setTimeout(resolve, 5000));
                attempts++;
              }
              
              // Check if workflow succeeded
              if (!workflowRun) {
                core.setFailed(`Workflow ${displayNumber} (${solution.app_name}) did not complete within the timeout period (15 minutes)`);
                throw new Error(`Workflow ${displayNumber} timed out`);
              }
              
              if (workflowRun.conclusion !== 'success') {
                core.setFailed(`Workflow ${displayNumber} (${solution.app_name}) failed with conclusion: ${workflowRun.conclusion}. View run: ${workflowRun.html_url}`);
                throw new Error(`Workflow ${displayNumber} failed, stopping execution`);
              }
              
              console.log(`✓ Workflow ${displayNumber} (${solution.app_name}) succeeded`);
              
              if (i < solutions.length - 1) {
                console.log(`Proceeding to next deployment...`);
              }
            }
            
            console.log(`\n========================================`);
            console.log(`✓ All ${totalCount} deployment(s) to QA completed successfully!`);
            console.log(`========================================`);

  OrchestrateProductionDeploy:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: Production
    runs-on: ubuntu-latest
    name: Orchestrate Production Deployment
    steps:
      - name: Check out
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 2
        env:
          GIT_LFS_SKIP_SMUDGE: 1

      - name: Detect solutions from commit
        id: detect
        run: |
          echo "Detecting solutions from commit changes..."
          
          # Get list of changed *_unmanaged.zip files in the last commit
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD | grep '_unmanaged.zip$' || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No *_unmanaged.zip files found in commit changes"
            echo "solutions=[]" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Read solution-groups.json to get proper ordering
          SOLUTION_GROUPS=$(cat SolutionGroups/solution-groups.json)
          
          # Process each file and create a map with ordering info
          declare -A SOLUTION_MAP
          while IFS= read -r file; do
            # Extract solution group and app name from path
            # Expected format: SolutionGroups/Library/LibraryTables_unmanaged.zip
            SOLUTION_GROUP=$(echo "$file" | cut -d'/' -f2)
            APP_NAME=$(basename "$file" _unmanaged.zip)
            
            # Find the index of this app in the solution group array
            INDEX=$(echo "$SOLUTION_GROUPS" | jq -r --arg sg "$SOLUTION_GROUP" --arg app "$APP_NAME" '.[$sg] | to_entries[] | select(.value == $app) | .key')
            
            if [ -n "$INDEX" ]; then
              # Store with key "group_index_appname" for sorting
              KEY="${SOLUTION_GROUP}_${INDEX}_${APP_NAME}"
              SOLUTION_MAP[$KEY]="${SOLUTION_GROUP}|${APP_NAME}|${INDEX}"
            else
              echo "Warning: App '$APP_NAME' not found in solution group '$SOLUTION_GROUP' in solution-groups.json"
            fi
          done <<< "$CHANGED_FILES"
          
          # Sort by solution group and index, then build JSON array in correct order
          SOLUTIONS="[]"
          for KEY in $(printf '%s\n' "${!SOLUTION_MAP[@]}" | sort); do
            VALUE="${SOLUTION_MAP[$KEY]}"
            SOLUTION_GROUP=$(echo "$VALUE" | cut -d'|' -f1)
            APP_NAME=$(echo "$VALUE" | cut -d'|' -f2)
            INDEX=$(echo "$VALUE" | cut -d'|' -f3)
            
            # Add to solutions array in order (use -c for compact output)
            SOLUTIONS=$(echo "$SOLUTIONS" | jq -c --arg sg "$SOLUTION_GROUP" --arg app "$APP_NAME" --argjson idx "$INDEX" '. += [{"solution_group": $sg, "app_name": $app, "order": $idx}]')
          done
          
          echo "solutions=$SOLUTIONS" >> $GITHUB_OUTPUT
          echo "Detected solutions in deployment order:"
          echo "$SOLUTIONS" | jq .

      - name: Orchestrate deployments to Production
        if: steps.detect.outputs.solutions != '[]'
        uses: actions/github-script@v7
        env:
          SOLUTIONS: ${{ steps.detect.outputs.solutions }}
        with:
          script: |
            const solutions = JSON.parse(process.env.SOLUTIONS);
            
            if (solutions.length === 0) {
              console.log('No solutions to deploy');
              return;
            }
            
            const totalCount = solutions.length;
            
            console.log(`Will deploy ${totalCount} solution(s) to Production`);
            
            // Deploy each solution sequentially
            for (let i = 0; i < solutions.length; i++) {
              const solution = solutions[i];
              const displayNumber = i + 1;
              
              console.log(`\n========================================`);
              console.log(`Triggering deployment ${displayNumber} of ${totalCount}`);
              console.log(`Solution: ${solution.solution_group} -> ${solution.app_name}`);
              console.log(`Environment: Production`);
              console.log(`========================================`);
              
              // Trigger the workflow
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'DeployOneSolution.yml',
                ref: 'main',
                inputs: {
                  solution_group: solution.solution_group,
                  app_name: solution.app_name,
                  environment: 'Production'
                }
              });
              
              // Wait a moment for the workflow to be created
              console.log(`Waiting for workflow to be created...`);
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Poll for workflow completion
              let workflowRun = null;
              let attempts = 0;
              const maxAttempts = 180; // 15 minutes max wait (180 * 5 seconds)
              let workflowStartLogged = false;
              
              while (attempts < maxAttempts) {
                // Get recent workflow runs
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'DeployOneSolution.yml',
                  per_page: 10
                });
                
                // Find the most recent run for main branch (should be the one we just triggered)
                const recentRun = runs.data.workflow_runs.find(run => 
                  run.head_branch === 'main' &&
                  (run.status === 'completed' || run.status === 'in_progress' || run.status === 'queued')
                );
                
                if (recentRun && !workflowStartLogged) {
                  console.log(`Workflow ${displayNumber} started: ${recentRun.html_url}`);
                  workflowStartLogged = true;
                }
                
                if (recentRun && recentRun.status === 'completed') {
                  workflowRun = recentRun;
                  console.log(`\nWorkflow ${displayNumber} completed with status: ${recentRun.conclusion}`);
                  console.log(`View workflow run: ${recentRun.html_url}`);
                  break;
                }
                
                if (attempts % 6 === 0) { // Log every 30 seconds
                  console.log(`Waiting for workflow ${displayNumber} to complete... (${Math.floor(attempts * 5 / 60)}m ${(attempts * 5) % 60}s elapsed)`);
                }
                
                await new Promise(resolve => setTimeout(resolve, 5000));
                attempts++;
              }
              
              // Check if workflow succeeded
              if (!workflowRun) {
                core.setFailed(`Workflow ${displayNumber} (${solution.app_name}) did not complete within the timeout period (15 minutes)`);
                throw new Error(`Workflow ${displayNumber} timed out`);
              }
              
              if (workflowRun.conclusion !== 'success') {
                core.setFailed(`Workflow ${displayNumber} (${solution.app_name}) failed with conclusion: ${workflowRun.conclusion}. View run: ${workflowRun.html_url}`);
                throw new Error(`Workflow ${displayNumber} failed, stopping execution`);
              }
              
              console.log(`✓ Workflow ${displayNumber} (${solution.app_name}) succeeded`);
              
              if (i < solutions.length - 1) {
                console.log(`Proceeding to next deployment...`);
              }
            }
            
            console.log(`\n========================================`);
            console.log(`✓ All ${totalCount} deployment(s) to Production completed successfully!`);
            console.log(`========================================`);

  OrchestrateManualDeploy:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    name: Orchestrate ${{ inputs.environment || '' }} Deployment
    steps:
      - name: Check out
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 1
        env:
          GIT_LFS_SKIP_SMUDGE: 1

      - name: Parse solution selection
        id: parse
        run: |
          SOLUTION="${{ inputs.solution }}"
          SOLUTION_GROUP=$(echo "$SOLUTION" | cut -d' ' -f1)
          APP_NAME=$(echo "$SOLUTION" | cut -d' ' -f3-)
          # Remove number prefix if present (e.g., "1. LibraryTables" -> "LibraryTables")
          APP_NAME=$(echo "$APP_NAME" | sed 's/^[0-9]\+\. //')
          echo "solution_group=$SOLUTION_GROUP" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Deploying: $SOLUTION_GROUP -> $APP_NAME to ${{ inputs.environment }}"

      - name: Orchestrate deployments
        uses: actions/github-script@v7
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          DEPLOY_DEPENDENCIES: ${{ inputs.deploy_dependencies }}
          SOLUTION_GROUP: ${{ steps.parse.outputs.solution_group }}
          APP_NAME: ${{ steps.parse.outputs.app_name }}
        with:
          script: |
            const fs = require('fs');
            
            // Use parsed values from the parse step
            const solutionGroup = process.env.SOLUTION_GROUP;
            const startAppName = process.env.APP_NAME;
            const environment = process.env.ENVIRONMENT;
            const deployDependent = process.env.DEPLOY_DEPENDENCIES === 'true';
            
            console.log(`Starting sequential deployment for: ${solutionGroup} -> ${startAppName}`);
            console.log(`Target environment: ${environment}`);
            console.log(`Deploy dependencies: ${deployDependent}`);
            
            // Read the solution groups mapping
            const solutionGroups = JSON.parse(fs.readFileSync('./SolutionGroups/solution-groups.json', 'utf8'));
            
            // Get apps array for the selected solution group
            if (!solutionGroups[solutionGroup]) {
              core.setFailed(`Solution group '${solutionGroup}' not found in mapping`);
              return;
            }
            
            const apps = solutionGroups[solutionGroup];
            
            // Find the starting app index
            const startIndex = apps.indexOf(startAppName);
            
            if (startIndex === -1) {
              core.setFailed(`App '${startAppName}' not found in solution group '${solutionGroup}'`);
              return;
            }
            
            // Determine which apps to deploy
            const appsToDeploy = deployDependent ? apps.slice(startIndex) : [startAppName];
            const totalCount = appsToDeploy.length;
            
            console.log(`Will deploy ${totalCount} app(s): ${appsToDeploy.join(', ')}`);
            
            // Deploy each app sequentially
            for (let i = 0; i < appsToDeploy.length; i++) {
              const appName = appsToDeploy[i];
              const displayNumber = i + 1;
              
              console.log(`\n========================================`);
              console.log(`Triggering deployment ${displayNumber} of ${totalCount}`);
              console.log(`App: ${solutionGroup} -> ${appName}`);
              console.log(`Environment: ${environment}`);
              console.log(`========================================`);
              
              // Trigger the workflow
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'DeployOneSolution.yml',
                ref: context.ref,
                inputs: {
                  solution_group: solutionGroup,
                  app_name: appName,
                  environment: environment
                }
              });
              
              // Wait a moment for the workflow to be created
              console.log(`Waiting for workflow to be created...`);
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Poll for workflow completion
              let workflowRun = null;
              let attempts = 0;
              const maxAttempts = 180; // 15 minutes max wait (180 * 5 seconds)
              let workflowStartLogged = false;
              
              while (attempts < maxAttempts) {
                // Get recent workflow runs
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'DeployOneSolution.yml',
                  per_page: 10
                });
                
                // Find the most recent run (should be the one we just triggered)
                const recentRun = runs.data.workflow_runs.find(run => 
                  (run.status === 'completed' || run.status === 'in_progress' || run.status === 'queued')
                );
                
                if (recentRun && !workflowStartLogged) {
                  console.log(`Workflow ${displayNumber} started: ${recentRun.html_url}`);
                  workflowStartLogged = true;
                }
                
                if (recentRun && recentRun.status === 'completed') {
                  workflowRun = recentRun;
                  console.log(`\nWorkflow ${displayNumber} completed with status: ${recentRun.conclusion}`);
                  console.log(`View workflow run: ${recentRun.html_url}`);
                  break;
                }
                
                if (attempts % 6 === 0) { // Log every 30 seconds
                  console.log(`Waiting for workflow ${displayNumber} to complete... (${Math.floor(attempts * 5 / 60)}m ${(attempts * 5) % 60}s elapsed)`);
                }
                
                await new Promise(resolve => setTimeout(resolve, 5000));
                attempts++;
              }
              
              // Check if workflow succeeded
              if (!workflowRun) {
                core.setFailed(`Workflow ${displayNumber} (${appName}) did not complete within the timeout period (15 minutes)`);
                throw new Error(`Workflow ${displayNumber} timed out`);
              }
              
              if (workflowRun.conclusion !== 'success') {
                core.setFailed(`Workflow ${displayNumber} (${appName}) failed with conclusion: ${workflowRun.conclusion}. View run: ${workflowRun.html_url}`);
                throw new Error(`Workflow ${displayNumber} failed, stopping execution`);
              }
              
              console.log(`✓ Workflow ${displayNumber} (${appName}) succeeded`);
              
              if (i < appsToDeploy.length - 1) {
                console.log(`Proceeding to next deployment...`);
              }
            }
            
            console.log(`\n========================================`);
            console.log(`✓ All ${totalCount} deployment(s) completed successfully!`);
            console.log(`========================================`);
