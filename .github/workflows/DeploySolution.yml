name: Deploy Solution
run-name: Deploy ${{ inputs.solution || 'Auto-triggered by changes' }}

on:
  workflow_dispatch:
    inputs:
      solution:
        description: 'Solution to deploy'
        required: true
        type: choice
        options:
          - 'Library -> 1. LibraryTables'
          - 'Library -> 2. LibraryApp'
      trigger_dependent_workflows:
        description: 'Trigger dependent workflows?'
        required: false
        default: false
        type: boolean
  pull_request:
    paths:
      - 'SolutionGroups/**/*_unmanaged.zip'

permissions:
  contents: read
  actions: write
  pull-requests: read

jobs:
  QA:
    environment: QA
    if: github.ref != 'refs/heads/main'
    name: QA - Deploy ${{ inputs.solution || 'Auto-triggered' }}
    runs-on: ubuntu-latest
    steps:
      - name: Check out
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 1
        env:
          GIT_LFS_SKIP_SMUDGE: 1

      - name: Parse solution selection
        id: parse
        run: |
          if [ -n "${{ inputs.solution }}" ]; then
            # Manual workflow dispatch - parse from input
            SOLUTION="${{ inputs.solution }}"
            SOLUTION_GROUP=$(echo "$SOLUTION" | cut -d' ' -f1)
            APP_NAME=$(echo "$SOLUTION" | cut -d' ' -f3-)
            # Remove number prefix if present (e.g., "1. LibraryTables" -> "LibraryTables")
            APP_NAME=$(echo "$APP_NAME" | sed 's/^[0-9]\+\. //')
          else
            # PR trigger - parse from changed files
            echo "Detecting solution from PR changes..."
            
            # Get list of changed files in the PR
            CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' | grep '_unmanaged.zip$' || true)
            
            if [ -z "$CHANGED_FILES" ]; then
              echo "Error: No *_unmanaged.zip files found in PR changes"
              exit 1
            fi
            
            # Take the first changed file and parse it
            FIRST_FILE=$(echo "$CHANGED_FILES" | head -n 1)
            echo "Processing file: $FIRST_FILE"
            
            # Extract solution group and app name from path
            # Expected format: SolutionGroups/Library/LibraryTables_unmanaged.zip
            SOLUTION_GROUP=$(echo "$FIRST_FILE" | cut -d'/' -f2)
            APP_NAME=$(basename "$FIRST_FILE" _unmanaged.zip)
            
            echo "Auto-detected from PR: $SOLUTION_GROUP -> $APP_NAME"
          fi
          
          echo "solution_group=$SOLUTION_GROUP" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Deploying: $SOLUTION_GROUP -> $APP_NAME"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Install Power Platform Tools
        uses: microsoft/powerplatform-actions/actions-install@v1

      - name: Pull only needed LFS files
        run: git lfs pull --include="SolutionGroups/${{ steps.parse.outputs.solution_group }}/${{ steps.parse.outputs.app_name }}.zip"

      - name: Import managed solution
        uses: microsoft/powerplatform-actions/import-solution@v1
        with:
          environment-url: ${{ secrets.ENVIRONMENT_URL }}
          app-id: ${{ secrets.CLIENT_ID }}
          client-secret: ${{ secrets.CLIENT_SECRET }}
          tenant-id: ${{ secrets.TENANT_ID }}
          solution-file: '${{ steps.parse.outputs.solution_group }}/${{ steps.parse.outputs.app_name }}.zip'
          working-directory: './SolutionGroups/'
          publish-changes: true

      - name: Trigger dependent workflows (optional)
        if: ${{ success() && inputs.trigger_dependent_workflows }}
        uses: actions/github-script@v7
        env:
          TARGET_REF: ${{ github.ref }}
          TRIGGER_DEPENDENT_WORKFLOWS: ${{ inputs.trigger_dependent_workflows }}
          SOLUTION_GROUP: ${{ steps.parse.outputs.solution_group }}
          APP_NAME: ${{ steps.parse.outputs.app_name }}
        with:
          script: |
            const fs = require('fs');
            
            // Use parsed values from the parse step
            const solutionGroup = process.env.SOLUTION_GROUP;
            const appName = process.env.APP_NAME;
            
            console.log(`Processing serial deployment for: ${solutionGroup} -> ${appName}`);
            
            // Read the solution groups mapping
            const solutionGroups = JSON.parse(fs.readFileSync('./SolutionGroups/solution-groups.json', 'utf8'));
            
            // Get apps array for the selected solution group
            if (!solutionGroups[solutionGroup]) {
              console.log(`Solution group '${solutionGroup}' not found in mapping`);
              return;
            }
            
            const apps = solutionGroups[solutionGroup];
            
            // Find the current app index
            const currentIndex = apps.indexOf(appName);
            
            if (currentIndex === -1) {
              console.log(`App '${appName}' not found in solution group '${solutionGroup}'`);
              return;
            }
            
            // Check if there's a next app to deploy
            if (currentIndex >= apps.length - 1) {
              console.log(`No more apps to deploy after ${appName} - this is the last app in the sequence.`);
              return;
            }
            
            // Get the next app in sequence
            const nextApp = apps[currentIndex + 1];
            const nextSelection = `${solutionGroup} -> ${nextApp}`;
            
            console.log(`Triggering next app in sequence: ${nextSelection}`);
            
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'DeploySolution.yml',
                ref: process.env.TARGET_REF,
                inputs: {
                  solution: nextSelection,
                  trigger_dependent_workflows: String(process.env.TRIGGER_DEPENDENT_WORKFLOWS)
                }
              });
              
              console.log(`Successfully triggered: ${nextSelection}`);
            } catch (error) {
              console.error(`Failed to trigger ${nextSelection}:`, error.message);
            }

  Production:
    environment: Production
    if: github.ref == 'refs/heads/main'
    name: Production - Deploy ${{ inputs.solution || 'Auto-triggered' }}
    runs-on: ubuntu-latest
    steps:
      - name: Check out
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 1
        env:
          GIT_LFS_SKIP_SMUDGE: 1

      - name: Parse solution selection
        id: parse
        run: |
          if [ -n "${{ inputs.solution }}" ]; then
            # Manual workflow dispatch - parse from input
            SOLUTION="${{ inputs.solution }}"
            SOLUTION_GROUP=$(echo "$SOLUTION" | cut -d' ' -f1)
            APP_NAME=$(echo "$SOLUTION" | cut -d' ' -f3-)
            # Remove number prefix if present (e.g., "1. LibraryTables" -> "LibraryTables")
            APP_NAME=$(echo "$APP_NAME" | sed 's/^[0-9]\+\. //')
          else
            # PR trigger - parse from changed files
            echo "Detecting solution from PR changes..."
            
            # Get list of changed files in the PR
            CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' | grep '_unmanaged.zip$' || true)
            
            if [ -z "$CHANGED_FILES" ]; then
              echo "Error: No *_unmanaged.zip files found in PR changes"
              exit 1
            fi
            
            # Take the first changed file and parse it
            FIRST_FILE=$(echo "$CHANGED_FILES" | head -n 1)
            echo "Processing file: $FIRST_FILE"
            
            # Extract solution group and app name from path
            # Expected format: SolutionGroups/Library/LibraryTables_unmanaged.zip
            SOLUTION_GROUP=$(echo "$FIRST_FILE" | cut -d'/' -f2)
            APP_NAME=$(basename "$FIRST_FILE" _unmanaged.zip)
            
            echo "Auto-detected from PR: $SOLUTION_GROUP -> $APP_NAME"
          fi
          
          echo "solution_group=$SOLUTION_GROUP" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Deploying: $SOLUTION_GROUP -> $APP_NAME"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Install Power Platform Tools
        uses: microsoft/powerplatform-actions/actions-install@v1

      - name: Pull only needed LFS files
        run: git lfs pull --include="SolutionGroups/${{ steps.parse.outputs.solution_group }}/${{ steps.parse.outputs.app_name }}.zip"

      - name: Import managed solution
        uses: microsoft/powerplatform-actions/import-solution@v1
        with:
          environment-url: ${{ secrets.ENVIRONMENT_URL }}
          app-id: ${{ secrets.CLIENT_ID }}
          client-secret: ${{ secrets.CLIENT_SECRET }}
          tenant-id: ${{ secrets.TENANT_ID }}
          solution-file: '${{ steps.parse.outputs.solution_group }}/${{ steps.parse.outputs.app_name }}.zip'
          working-directory: './SolutionGroups/'
          publish-changes: true

      - name: Trigger dependent workflows (optional)
        if: ${{ success() && inputs.trigger_dependent_workflows }}
        uses: actions/github-script@v7
        env:
          TARGET_REF: ${{ github.ref }}
          TRIGGER_DEPENDENT_WORKFLOWS: ${{ inputs.trigger_dependent_workflows }}
          SOLUTION_GROUP: ${{ steps.parse.outputs.solution_group }}
          APP_NAME: ${{ steps.parse.outputs.app_name }}
        with:
          script: |
            const fs = require('fs');
            
            // Use parsed values from the parse step
            const solutionGroup = process.env.SOLUTION_GROUP;
            const appName = process.env.APP_NAME;
            
            console.log(`Processing serial deployment for: ${solutionGroup} -> ${appName}`);
            
            // Read the solution groups mapping
            const solutionGroups = JSON.parse(fs.readFileSync('./SolutionGroups/solution-groups.json', 'utf8'));
            
            // Get apps array for the selected solution group
            if (!solutionGroups[solutionGroup]) {
              console.log(`Solution group '${solutionGroup}' not found in mapping`);
              return;
            }
            
            const apps = solutionGroups[solutionGroup];
            
            // Find the current app index
            const currentIndex = apps.indexOf(appName);
            
            if (currentIndex === -1) {
              console.log(`App '${appName}' not found in solution group '${solutionGroup}'`);
              return;
            }
            
            // Check if there's a next app to deploy
            if (currentIndex >= apps.length - 1) {
              console.log(`No more apps to deploy after ${appName} - this is the last app in the sequence.`);
              return;
            }
            
            // Get the next app in sequence
            const nextApp = apps[currentIndex + 1];
            const nextSelection = `${solutionGroup} -> ${nextApp}`;
            
            console.log(`Triggering next app in sequence: ${nextSelection}`);
            
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'DeploySolution.yml',
                ref: process.env.TARGET_REF,
                inputs: {
                  solution: nextSelection,
                  trigger_dependent_workflows: String(process.env.TRIGGER_DEPENDENT_WORKFLOWS)
                }
              });
              
              console.log(`Successfully triggered: ${nextSelection}`);
            } catch (error) {
              console.error(`Failed to trigger ${nextSelection}:`, error.message);
            }
