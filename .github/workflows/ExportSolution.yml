name: Export Solutions (Orchestrator)
run-name: Export ${{ inputs.solution }}${{ inputs.export_dependencies && ' with dependencies' || '' }}

on:
  workflow_dispatch:
    inputs:
      solution:
        description: 'Solution to export'
        required: true
        type: choice
        options:
          - 'Calculator -> 1. Calculator'
          - 'Library -> 1. LibraryTables'
          - 'Library -> 2. LibraryApp'
          - 'MyVacations -> 1. MyVacationsTables'
          - 'MyVacations -> 2. MyVacationsApp'
          - 'Garage -> 1. Garage'
      branch_name:
        description: 'Branch name for export (e.g., "features/app-export"). Leave empty for auto-generated name with timestamp.'
        required: false
        type: string

      export_dependencies:
        description: 'Export dependencies?'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  actions: write
  pull-requests: write

jobs:
  OrchestrateExport:
    runs-on: ubuntu-latest
    name: Orchestrate Export
    steps:
      - name: Check out
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
        env:
          GIT_LFS_SKIP_SMUDGE: 1

      - name: Validate branch name
        id: validate_branch
        run: |
          BRANCH_NAME="${{ inputs.branch_name }}"
          
          # If no branch name provided, auto-generate with timestamp
          if [ -z "$BRANCH_NAME" ]; then
            TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
            BRANCH_NAME="features/export-solution-${TIMESTAMP}"
            echo "No branch name provided, auto-generated: $BRANCH_NAME"
          fi
          
          # Validate branch name
          if [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ]; then
            echo "Error: Cannot export to main/master branch"
            echo "Please specify a different branch name for exports"
            exit 1
          fi
          
          echo "Branch name validation passed: $BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create or switch to branch
        run: |
          BRANCH_NAME="${{ steps.validate_branch.outputs.branch_name }}"
          
          # Configure git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Fetch all branches
          git fetch origin
          
          # Check if branch exists remotely
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch '$BRANCH_NAME' exists remotely, checking it out..."
            git checkout "$BRANCH_NAME"
            git pull origin "$BRANCH_NAME"
          # Check if branch exists locally
          elif git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
            echo "Branch '$BRANCH_NAME' exists locally, checking it out..."
            git checkout "$BRANCH_NAME"
          else
            echo "Creating new branch '$BRANCH_NAME'..."
            git checkout -b "$BRANCH_NAME"
          fi
          
          echo "Current branch: $(git branch --show-current)"
          
          # Push the branch if it's new
          if ! git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Pushing new branch to remote..."
            git push -u origin "$BRANCH_NAME"
          fi

      - name: Parse solution selection
        id: parse
        run: |
          SOLUTION="${{ inputs.solution }}"
          SOLUTION_GROUP=$(echo "$SOLUTION" | cut -d' ' -f1)
          APP_NAME=$(echo "$SOLUTION" | cut -d' ' -f3-)
          # Remove number prefix if present (e.g., "1. LibraryTables" -> "LibraryTables")
          APP_NAME=$(echo "$APP_NAME" | sed 's/^[0-9]\+\. //')
          echo "solution_group=$SOLUTION_GROUP" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Exporting: $SOLUTION_GROUP -> $APP_NAME"

      - name: Orchestrate sequential exports
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ steps.validate_branch.outputs.branch_name }}
          EXPORT_DEPENDENCIES: ${{ inputs.export_dependencies }}
          SOLUTION_GROUP: ${{ steps.parse.outputs.solution_group }}
          APP_NAME: ${{ steps.parse.outputs.app_name }}
        with:
          script: |
            const fs = require('fs');
            
            // Use parsed values from the parse step
            const solutionGroup = process.env.SOLUTION_GROUP;
            const startAppName = process.env.APP_NAME;
            const branchName = process.env.BRANCH_NAME;
            const triggerDependent = process.env.EXPORT_DEPENDENCIES === 'true';
            
            console.log(`Starting sequential export for: ${solutionGroup} -> ${startAppName}`);
            console.log(`Target branch: ${branchName}`);
            console.log(`Trigger dependent workflows: ${triggerDependent}`);
            
            // Read the solution groups mapping
            const solutionGroups = JSON.parse(fs.readFileSync('./SolutionGroups/solution-groups.json', 'utf8'));
            
            // Get apps array for the selected solution group
            if (!solutionGroups[solutionGroup]) {
              core.setFailed(`Solution group '${solutionGroup}' not found in mapping`);
              return;
            }
            
            const apps = solutionGroups[solutionGroup];
            
            // Find the starting app index
            const startIndex = apps.indexOf(startAppName);
            
            if (startIndex === -1) {
              core.setFailed(`App '${startAppName}' not found in solution group '${solutionGroup}'`);
              return;
            }
            
            // Determine which apps to export
            const appsToExport = triggerDependent ? apps.slice(startIndex) : [startAppName];
            const totalCount = appsToExport.length;
            
            console.log(`Will export ${totalCount} app(s): ${appsToExport.join(', ')}`);
            
            // Export each app sequentially
            for (let i = 0; i < appsToExport.length; i++) {
              const appName = appsToExport[i];
              const displayNumber = i + 1;
              
              console.log(`\n========================================`);
              console.log(`Triggering workflow ${displayNumber} of ${totalCount}`);
              console.log(`App: ${solutionGroup} -> ${appName}`);
              console.log(`========================================`);
              
              // Trigger the workflow
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'ExportOneSolution.yml',
                ref: branchName,
                inputs: {
                  solution_group: solutionGroup,
                  app_name: appName,
                  branch_name: branchName
                }
              });
              
              // Wait a moment for the workflow to be created
              console.log(`Waiting for workflow to be created...`);
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Poll for workflow completion
              let workflowRun = null;
              let attempts = 0;
              const maxAttempts = 360; // 30 minutes max wait (360 * 5 seconds)
              
              while (attempts < maxAttempts) {
                // Get recent workflow runs with retry logic
                let runs;
                let retryCount = 0;
                const maxRetries = 3;
                
                while (retryCount < maxRetries) {
                  try {
                    runs = await github.rest.actions.listWorkflowRuns({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      workflow_id: 'ExportOneSolution.yml',
                      per_page: 10
                    });
                    break; // Success, exit retry loop
                  } catch (error) {
                    retryCount++;
                    if (retryCount >= maxRetries) {
                      console.error(`Failed to fetch workflow runs after ${maxRetries} retries: ${error.message}`);
                      throw error;
                    }
                    const retryDelay = Math.min(1000 * Math.pow(2, retryCount), 10000); // Exponential backoff, max 10s
                    console.log(`API call failed (attempt ${retryCount}/${maxRetries}), retrying in ${retryDelay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                  }
                }
                
                // Find the most recent run for this branch (should be the one we just triggered)
                const recentRun = runs.data.workflow_runs.find(run => 
                  run.head_branch === branchName &&
                  (run.status === 'completed' || run.status === 'in_progress' || run.status === 'queued' || run.status === 'waiting')
                );
                
                if (recentRun && recentRun.status === 'completed') {
                  workflowRun = recentRun;
                  console.log(`\nWorkflow ${displayNumber} completed with status: ${recentRun.conclusion}`);
                  console.log(`View workflow run: ${recentRun.html_url}`);
                  break;
                }
                
                if (recentRun && attempts === 0) {
                  console.log(`Workflow ${displayNumber} started: ${recentRun.html_url}`);
                }
                
                if (attempts % 6 === 0) { // Log every 30 seconds
                  console.log(`Waiting for workflow ${displayNumber} to complete... (${Math.floor(attempts * 5 / 60)}m ${(attempts * 5) % 60}s elapsed)`);
                }
                
                await new Promise(resolve => setTimeout(resolve, 5000));
                attempts++;
              }
              
              // Check if workflow succeeded
              if (!workflowRun) {
                core.setFailed(`Workflow ${displayNumber} (${appName}) did not complete within the timeout period (15 minutes)`);
                throw new Error(`Workflow ${displayNumber} timed out`);
              }
              
              if (workflowRun.conclusion !== 'success') {
                core.setFailed(`Workflow ${displayNumber} (${appName}) failed with conclusion: ${workflowRun.conclusion}. View run: ${workflowRun.html_url}`);
                throw new Error(`Workflow ${displayNumber} failed, stopping execution`);
              }
              
              console.log(`✓ Workflow ${displayNumber} (${appName}) succeeded`);
              
              if (i < appsToExport.length - 1) {
                console.log(`Proceeding to next workflow...`);
              }
            }
            
            console.log(`\n========================================`);
            console.log(`✓ All ${totalCount} workflow(s) completed successfully!`);
            console.log(`========================================`);

      - name: Create Pull Request
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ steps.validate_branch.outputs.branch_name }}
          SOLUTION: ${{ inputs.solution }}
          EXPORT_DEPENDENCIES: ${{ inputs.export_dependencies }}
        with:
          script: |
            const branchName = process.env.BRANCH_NAME;
            const solution = process.env.SOLUTION;
            const triggerDependent = process.env.EXPORT_DEPENDENCIES === 'true';
            
            // Check if PR already exists
            const { data: existingPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branchName}`,
              base: 'main',
              state: 'open'
            });
            
            if (existingPRs.length > 0) {
              console.log(`Pull request already exists: ${existingPRs[0].html_url}`);
              console.log(`PR #${existingPRs[0].number}: ${existingPRs[0].title}`);
              return;
            }
            
            // Create new PR
            const title = `Export ${solution}${triggerDependent ? ' with dependencies' : ''}`;
            const body = `## Automated Solution Export
            
            **Solution:** ${solution}
            **Branch:** ${branchName}
            **Export Type:** ${triggerDependent ? 'Sequential (with dependencies)' : 'Single solution'}
            **Triggered by:** @${context.actor}
            
            This PR contains the exported Power Platform solution(s) from the Development environment.
            
            ### Next Steps
            - Review the changes
            - Automated deployment to QA has been initiated
            - Merge to deploy to Production environment
            `;
            
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              head: branchName,
              base: 'main',
              body: body
            });
            
            console.log(`\n✓ Pull request created successfully!`);
            console.log(`PR #${pr.number}: ${pr.html_url}`);

      - name: Trigger QA Deployment
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ steps.validate_branch.outputs.branch_name }}
          SOLUTION: ${{ inputs.solution }}
          EXPORT_DEPENDENCIES: ${{ inputs.export_dependencies }}
        with:
          script: |
            const branchName = process.env.BRANCH_NAME;
            const solution = process.env.SOLUTION;
            const exportDependencies = process.env.EXPORT_DEPENDENCIES === 'true';
            
            console.log(`\n========================================`);
            console.log(`Triggering QA deployment orchestrator`);
            console.log(`Solution: ${solution}`);
            console.log(`Deploy dependencies: ${exportDependencies}`);
            console.log(`========================================`);
            
            try {
              // Trigger the DeploySolution orchestrator workflow
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'DeploySolution.yml',
                ref: branchName,
                inputs: {
                  solution: solution,
                  environment: 'QA',
                  deploy_dependencies: String(exportDependencies)
                }
              });
              
              console.log(`\n✓ QA deployment orchestrator triggered successfully`);
              console.log(`The orchestrator will detect all solutions and deploy them sequentially`);
              console.log(`Check the Actions tab for deployment progress`);
              
            } catch (error) {
              console.error(`Error triggering QA deployment: ${error.message}`);
              console.log('You can manually trigger deployment or close/reopen the PR to retry');
            }

