name: Export Solution
run-name: Export ${{ inputs.solution }}

on:
  workflow_dispatch:
    inputs:
      solution:
        description: 'Solution to export'
        required: true
        type: choice
        options:
          - 'Library -> 1. LibraryTables'
          - 'Library -> 2. LibraryApp'
      branch_name:
        description: 'Branch name for export (will be created if it does not exist)'
        required: true
        type: string
        default: 'export-solution'
      trigger_dependent_workflows:
        description: 'Trigger dependent workflows?'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  actions: write

jobs:
  ExportSolution:
    environment: Development
    name: Export ${{ inputs.solution }}
    runs-on: ubuntu-latest
    steps:
      - name: Check out
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
        env:
          GIT_LFS_SKIP_SMUDGE: 1

      - name: Create or switch to branch
        run: |
          BRANCH_NAME="${{ inputs.branch_name }}"
          
          # Configure git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Fetch all branches
          git fetch origin
          
          # Check if branch exists remotely
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch '$BRANCH_NAME' exists remotely, checking it out..."
            git checkout "$BRANCH_NAME"
            git pull origin "$BRANCH_NAME"
          # Check if branch exists locally
          elif git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
            echo "Branch '$BRANCH_NAME' exists locally, checking it out..."
            git checkout "$BRANCH_NAME"
          else
            echo "Creating new branch '$BRANCH_NAME'..."
            git checkout -b "$BRANCH_NAME"
          fi
          
          echo "Current branch: $(git branch --show-current)"

      - name: Parse solution selection
        id: parse
        run: |
          SOLUTION="${{ inputs.solution }}"
          SOLUTION_GROUP=$(echo "$SOLUTION" | cut -d' ' -f1)
          APP_NAME=$(echo "$SOLUTION" | cut -d' ' -f3-)
          # Remove number prefix if present (e.g., "1. LibraryTables" -> "LibraryTables")
          APP_NAME=$(echo "$APP_NAME" | sed 's/^[0-9]\+\. //')
          echo "solution_group=$SOLUTION_GROUP" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Exporting: $SOLUTION_GROUP -> $APP_NAME"

      - name: Install Power Platform Tools
        uses: microsoft/powerplatform-actions/actions-install@v1

      - name: Export unmanaged solution
        uses: microsoft/powerplatform-actions/export-solution@v1
        with:
          environment-url: ${{ secrets.ENVIRONMENT_URL }}
          app-id: ${{ secrets.CLIENT_ID }}
          client-secret: ${{ secrets.CLIENT_SECRET }}
          tenant-id: ${{ secrets.TENANT_ID }}
          solution-name: ${{ steps.parse.outputs.app_name }}
          solution-output-file: '${{ steps.parse.outputs.solution_group }}/${{ steps.parse.outputs.app_name }}_unmanaged.zip'
          working-directory: './SolutionGroups/'
          overwrite: true
          managed: false

      - name: Export managed solution
        uses: microsoft/powerplatform-actions/export-solution@v1
        with:
          environment-url: ${{ secrets.ENVIRONMENT_URL }}
          app-id: ${{ secrets.CLIENT_ID }}
          client-secret: ${{ secrets.CLIENT_SECRET }}
          tenant-id: ${{ secrets.TENANT_ID }}
          solution-name: ${{ steps.parse.outputs.app_name }}
          solution-output-file: '${{ steps.parse.outputs.solution_group }}/${{ steps.parse.outputs.app_name }}.zip'
          working-directory: './SolutionGroups/'
          overwrite: true
          managed: true

      - name: Commit changes
        run: |
          BRANCH_NAME="${{ inputs.branch_name }}"
          
          git add .
            
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            # Commit the changes first
            git commit -m "Export of ${{ inputs.solution }} - Updated by ${{ github.actor }}"
            
            # Retry logic for push conflicts
            MAX_RETRIES=5
            RETRY_COUNT=0
            RETRY_DELAY=5
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES to push changes"
              
              # Try to push
              if git push origin "$BRANCH_NAME"; then
                echo "Changes pushed successfully to branch '$BRANCH_NAME'"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Push failed, pulling latest changes and retrying..."
                  
                  # Pull with rebase to get latest changes
                  if git pull --rebase origin "$BRANCH_NAME"; then
                    echo "Rebased successfully, waiting $RETRY_DELAY seconds before retry..."
                    sleep $RETRY_DELAY
                    RETRY_DELAY=$((RETRY_DELAY + 5))  # Exponential backoff
                  else
                    echo "Rebase failed, trying to abort and continue..."
                    git rebase --abort || true
                    sleep $RETRY_DELAY
                    RETRY_DELAY=$((RETRY_DELAY + 5))
                  fi
                else
                  echo "Failed to push after $MAX_RETRIES attempts"
                  exit 1
                fi
              fi
            done
          fi

      - name: Trigger dependent workflows (optional)
        if: ${{ success() && inputs.trigger_dependent_workflows }}
        uses: actions/github-script@v7
        env:
          TARGET_BRANCH: ${{ inputs.branch_name }}
          TRIGGER_DEPENDENT_WORKFLOWS: ${{ inputs.trigger_dependent_workflows }}
          SOLUTION_GROUP: ${{ steps.parse.outputs.solution_group }}
          APP_NAME: ${{ steps.parse.outputs.app_name }}
        with:
          script: |
            const fs = require('fs');
            
            // Use parsed values from the parse step
            const solutionGroup = process.env.SOLUTION_GROUP;
            const appName = process.env.APP_NAME;
            const targetBranch = process.env.TARGET_BRANCH;
            
            console.log(`Processing dependencies for: ${solutionGroup} -> ${appName}`);
            console.log(`Target branch: ${targetBranch}`);
            
            // Read the solution groups mapping
            const solutionGroups = JSON.parse(fs.readFileSync('./SolutionGroups/solution-groups.json', 'utf8'));
            
            // Get dependent apps for the selected solution
            if (!solutionGroups[solutionGroup]) {
              console.log(`Solution group '${solutionGroup}' not found in mapping`);
              return;
            }
            
            if (!solutionGroups[solutionGroup][appName]) {
              console.log(`App '${appName}' not found in solution group '${solutionGroup}'`);
              return;
            }
            
            const dependentApps = solutionGroups[solutionGroup][appName];
            
            if (dependentApps.length === 0) {
              console.log(`No dependent workflows to trigger for ${appName} - this app has no dependencies defined.`);
              return;
            }
            
            console.log(`Found ${dependentApps.length} dependent app(s): ${dependentApps.join(', ')}`);
            
            // Process each dependent app
            for (const dependentApp of dependentApps) {
              const dependentSelection = `${solutionGroup} -> ${dependentApp}`;
              console.log(`Triggering workflow for: ${dependentSelection} on branch ${targetBranch}`);
              
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'ExportSolution.yml',
                  ref: targetBranch,
                  inputs: {
                    solution: dependentSelection,
                    branch_name: targetBranch,
                    trigger_dependent_workflows: String(process.env.TRIGGER_DEPENDENT_WORKFLOWS)
                  }
                });
                
                console.log(`Successfully triggered: ${dependentSelection}`);
              } catch (error) {
                console.error(`Failed to trigger ${dependentSelection}:`, error.message);
                // Continue with next workflow instead of failing completely
              }
            }
